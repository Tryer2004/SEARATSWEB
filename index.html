<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sea Rats</title>

<style>
/* ================= DESIGN SYSTEM ================= */
:root {
  --primary: #3b82f6;
  --bg: #ffffff;
  --card: #f9fafb;
  --text: #111827;
  --muted: #6b7280;
  --border: #e5e7eb;
}

[data-theme="dark"] {
  --bg: #0f172a;
  --card: #1f2937;
  --text: #e5e7eb;
  --muted: #9ca3af;
  --border: #374151;
}

/* ================= BASE ================= */
body {
  margin: 0;
  font-family: Inter, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
}

h1,h2,h3 {
  letter-spacing: -0.02em;
}

p {
  max-width: 700px;
  line-height: 1.7;
  color: var(--muted);
  
}

/* ================= NAVBAR ================= */
.navbar {
  background: rgba(15,23,42,0.9);
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  backdrop-filter: blur(10px);
  z-index: 10;
}

.nav-container {
  max-width: 1200px;
  margin: auto;
  padding: 16px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.navbar ul {
  list-style: none;
  display: flex;
  gap: 24px;
  padding: 0;
  margin: 0;
}

.navbar a {
  text-decoration: none;
  color: var(--muted);
}

.navbar a:hover {
  color: var(--primary);
}

/* ================= HERO ================= */
.hero {
  text-align: center;
  padding: 120px 24px 80px;
}

.hero h1 {
  letter-spacing: -0.03;
 background: linear-gradient(90deg, #60a5fa, #3b82f6);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;



  font-size: 4.5rem;
  font-weight: 700;
  margin-bottom: 16px;
  /* Animation */

  opacity: 0;
  transform: translateY(20px);
  animation: heroFadeUp 4s ease-out forwards;
  animation-delay: 0.27s;
}





.hero p {
  font-size: 1.35rem;
  max-width: 600px;
  margin: 0 auto;
  color: var(--muted);

  /* Animation */
  opacity: 0;
  transform: translateY(20px);
  animation: heroFadeUp 34s ease-out forwards;
  animation-delay: 0.30s;
}

/* Keyframes */

@keyframes heroFadeUp {
  to {
    opacity: 1;
    transform: translateY(0);

  }
}

/* ================= SECTIONS / CARDS ================= */
section {
  max-width: 900px;
  margin: 80px auto;
}

.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 32px;
}

/* ================= GAME ================= */
#gameCanvas {
  display: block;
  margin: 32px auto;
  background: #0b3c5d;
  border-radius: 12px;
  border: 2px solid var(--border);
}
</style>
</head>

<body>

<!-- ================= NAVBAR ================= -->
<nav class="navbar">
  <div class="nav-container">
    <strong>Sea Rats</strong>
    <button id="theme-toggle">ðŸŒ™</button>
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="about.html">About</a></li>
      <li><a href="Donate.html">Donate</a></li>
    </ul>
  </div>
</nav>

<!-- ================= HERO ================= -->
<header class="hero">
  <h1>Sea Rats</h1>
  <p>Building underwater robotics to monitor and protect our oceans.</p>
</header>

<!-- ================= ABOUT ================= -->
<section class="card">
  <h2>About Sea Rats</h2>
  <p>
    Founded in 2024, Sea Rats competes in the SeaMate ROV competition.
    After winning all Scout-level awards, the team now competes at the
    Ranger level, focusing on ocean monitoring and climate mitigation.
  </p>
</section>

<!-- ================= GAME ================= -->
<section class="card">
  <h2>Underwater Robotics Simulator</h2>
  <p>
    Test your piloting skills in a simplified ROV navigation challenge.
    Tap, click, or press space to control the robot.
  </p>

  <canvas id="gameCanvas" width="400" height="600"></canvas>
</section>





     <script> 


let gameState = "start";
let gameSpeedMultiplier = 1;
let gamePaused = false;
let scoreMultiplier = 1;

// ===== PAUSE MENU =====
const pauseMenu = document.createElement("div");
pauseMenu.style.position = "fixed";
pauseMenu.style.top = "0";
pauseMenu.style.left = "0";
pauseMenu.style.width = "100%";
pauseMenu.style.height = "100%";
pauseMenu.style.backgroundColor = "rgba(0,0,0,0.8)";
pauseMenu.style.color = "white";
pauseMenu.style.display = "none";
pauseMenu.style.flexDirection = "column";
pauseMenu.style.alignItems = "center";
pauseMenu.style.justifyContent = "center";
pauseMenu.style.fontFamily = "sans-serif";
pauseMenu.style.zIndex = "1000";
pauseMenu.style.textAlign = "center";
document.body.appendChild(pauseMenu);

const pauseScore = document.createElement("h2");
pauseMenu.appendChild(pauseScore);

const resumeBtn = document.createElement("button");
resumeBtn.textContent = "Resume";
resumeBtn.style.fontSize = "1.5em";
resumeBtn.style.margin = "10px";
pauseMenu.appendChild(resumeBtn);

const settingsBtn = document.createElement("button");
settingsBtn.textContent = "Settings";
settingsBtn.style.fontSize = "1.5em";
settingsBtn.style.margin = "10px";
pauseMenu.appendChild(settingsBtn);

const settingsPanel = document.createElement("div");
settingsPanel.style.display = "none";
settingsPanel.style.flexDirection = "column";
settingsPanel.style.alignItems = "center";
settingsPanel.style.marginTop = "20px";
pauseMenu.appendChild(settingsPanel);

const speedLabel = document.createElement("h3");
speedLabel.textContent = "Game Speed:";
settingsPanel.appendChild(speedLabel);

const speeds = [0.5, 1, 1.5];
speeds.forEach(mult => {
  const btn = document.createElement("button");
  btn.textContent = mult + "x";
  btn.style.margin = "5px";
  btn.onclick = () => {
    scoreMultiplier = mult;
    gameSpeedMultiplier = mult;
  };
  settingsPanel.appendChild(btn);
});

function togglePause() {
  gamePaused = !gamePaused;
  pauseMenu.style.display = gamePaused ? "flex" : "none";
  settingsPanel.style.display = "none";
  pauseScore.textContent = "Score: " + Math.floor(score);
}

resumeBtn.onclick = () => togglePause();
settingsBtn.onclick = () => {
  settingsPanel.style.display = settingsPanel.style.display === "none" ? "flex" : "none";
};

document.addEventListener("keydown", e => {
  if (e.code === "Escape") {
    togglePause();
  }
});

// ===== CANVAS SETUP =====
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// ===== MOBILE PAUSE BUTTON (FIXED) =====
const pauseButton = document.createElement("button");
pauseButton.textContent = "â¸";
pauseButton.style.position = "absolute";
pauseButton.style.fontSize = "2em";
pauseButton.style.zIndex = "1000";
pauseButton.style.background = "rgba(0,0,0,0.5)";
pauseButton.style.color = "white";
pauseButton.style.border = "none";
pauseButton.style.borderRadius = "5px";
pauseButton.style.padding = "5px 10px";
document.body.appendChild(pauseButton);

function updatePauseButtonPosition() {
  const rect = canvas.getBoundingClientRect();
  pauseButton.style.top = rect.top + window.scrollY + 10 + "px";
  pauseButton.style.left = rect.left + window.scrollX + rect.width - 50 + "px";
}

pauseButton.addEventListener("click", togglePause);

window.addEventListener("resize", updatePauseButtonPosition);
window.addEventListener("scroll", updatePauseButtonPosition);
updatePauseButtonPosition();

// ===== OFFLINE STATUS =====
const offlineStatus = document.createElement("div");
offlineStatus.style.textAlign = "center";
offlineStatus.style.fontFamily = "sans-serif";
offlineStatus.style.color = "#00ffcc";
offlineStatus.style.marginTop = "10px";
offlineStatus.style.display = "none";
offlineStatus.textContent = "ðŸ“´ Offline Mode Enabled";
document.body.appendChild(offlineStatus);

function updateOfflineStatus() {
  offlineStatus.style.display = navigator.onLine ? "none" : "block";
}
window.addEventListener("online", updateOfflineStatus);
window.addEventListener("offline", updateOfflineStatus);
updateOfflineStatus();

// ===== DARK MODE =====
const toggle = document.getElementById("theme-toggle");
toggle.addEventListener("click", () => {
  const htmlEl = document.documentElement;
  const current = htmlEl.getAttribute("data-theme");
  htmlEl.setAttribute("data-theme", current === "dark" ? "light" : "dark");
});

// ===== GAME STATE =====
let robotY = 300;
let robotVelocity = 0;
const robotSize = 25;
const robotWidth = 40;
const gravity = 0.5;
const thrust = -8;

let frameCount = 0;
let score = 0;
let highscore = parseInt(localStorage.getItem("highScore")) || 0;

const obstacles = [];
const obstacleWidth = 50;
const obstacleGap = 160;
let obstacleSpeed = 2;
let lastGapY = canvas.height / 2;

const bubbles = [];
for (let i = 0; i < 25; i++) {
  bubbles.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    radius: Math.random() * 3 + 2,
    speed: Math.random() * 0.6 + 0.2
  });
}

const explosions = [];
function triggerExplosion(x, y) {
  explosions.push({
    x: x,
    y: y,
    size: 100,
    frames: 75,
    particles: 10000,
    opacity: 1
  });
}

function drawExplosions() {
  explosions.forEach((expl, index) => {
    for (let i = 0; i < 20; i++) {
      const px = expl.x + (Math.random() - 0.1) * expl.size;
      const py = expl.y + (Math.random() - 0.1) * expl.size;
      ctx.fillStyle = `rgba(255,100,0,${expl.opacity})`;
      ctx.fillRect(px, py, 3, 3);
    }
    expl.opacity -= 0.020;
    expl.frames--;
    expl.size += 2;
    if (expl.frames <= 0) {
      explosions.splice(index, 1);
      if (gameState === "exploding") gameState = "gameover";
    }
  });
}

function drawBubbles() {
  ctx.fillStyle = "rgba(255,255,255,0.35)";
  bubbles.forEach(bubble => {
    bubble.y -= bubble.speed;
    if (bubble.y < -10) {
      bubble.y = canvas.height + 10;
      bubble.x = Math.random() * canvas.width;
    }
    ctx.beginPath();
    ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
    ctx.fill();
  });
}

function createObstacle() {
  const maxChange = 100;
  let gapY = lastGapY + (Math.random() * 2 - 1) * maxChange;
  gapY = Math.max(25, Math.min(canvas.height - obstacleGap - 25, gapY));
  obstacles.push({ x: canvas.width, gapY, passed: false });
  lastGapY = gapY;
}

function drawObstacles() {
  ctx.fillStyle = "#065f46";
  obstacles.forEach(ob => {
    ctx.fillRect(ob.x, 0, obstacleWidth, ob.gapY);
    ctx.fillRect(ob.x, ob.gapY + obstacleGap, obstacleWidth, canvas.height - (ob.gapY + obstacleGap));
    ob.x -= obstacleSpeed * gameSpeedMultiplier;
  });
}

function drawRobot() {
  if (gameState !== "exploding"){
    ctx.fillStyle = "#facc15";
    ctx.fillRect(170, robotY, robotWidth, robotSize);
    ctx.fillStyle = "#38bdf8";
    ctx.fillRect(180, robotY + 5, 10, 10);
    ctx.fillStyle = "rgba(255,255,255,0.6)";
    ctx.beginPath();
    ctx.arc(165, robotY + 12, 4, 0, Math.PI * 2);
    ctx.fill();
  }
}

function updateRobot() {
  robotVelocity += gravity * gameSpeedMultiplier;
  robotY += robotVelocity * gameSpeedMultiplier;
}

function checkCollision() {
  const robotX = 170;
  obstacles.forEach(ob => {
    if (robotX + robotWidth > ob.x && robotX < ob.x + obstacleWidth) {
      if (robotY < ob.gapY || robotY + robotSize > ob.gapY + obstacleGap) {
        if (gameState !== "exploding" && gameState !== "gameover") {
          triggerExplosion(robotX, robotY + robotSize / 2);
          gameState = "exploding";
        }
      }
    }
    if (!ob.passed && ob.x + obstacleWidth < robotX) {
      ob.passed = true;
      score += scoreMultiplier;
      if (score > highscore) {
        highscore = score;
        localStorage.setItem("highScore", highscore);
      }
    }
  });

  if (robotY < 0 || robotY + robotSize > canvas.height) {
    if (gameState !== "exploding" && gameState !== "gameover") {
      triggerExplosion(robotX, robotY + robotSize / 2);
      gameState = "exploding";
    }
  }
}

function drawUI() {
  ctx.fillStyle = "white";
  ctx.font = "20px sans-serif";
  ctx.fillText("Score: " + Math.floor(score), 20, 30);
  ctx.fillText("Highscore: " + highscore, 20, 60);

  ctx.textAlign = "center";
  if (gameState === "start") {
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "white";
    ctx.font = "28px sans-serif";
    ctx.fillText("UNDERWATER ROV", canvas.width / 2, 260);
    ctx.font = "18px sans-serif";
    ctx.fillText("Tap or Press Space to Start", canvas.width / 2, 310);
  }

  if (gameState === "gameover") {
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "white";
    ctx.font = "28px sans-serif";
    ctx.fillText("GAME OVER", canvas.width / 2, 260);
    ctx.font = "18px sans-serif";
    ctx.fillText("Tap or Press Space to Restart", canvas.width / 2, 310);
  }
  ctx.textAlign = "left";
}

function resetGame() {
  robotY = 300;
  robotVelocity = 0;
  obstacles.length = 0;
  score = 0;
  frameCount = 0;
  obstacleSpeed = 2;
  lastGapY = canvas.height / 2;
  gameState = "playing";
}

// ===== CONTROLS =====
document.addEventListener("keydown", e => {
  if (e.code === "Space") {
    if (gameState === "start") gameState = "playing";
    else if (gameState === "gameover") resetGame();
    else if (gameState === "playing") robotVelocity = thrust;
  }
});

canvas.addEventListener("click", () => {
  if (gameState === "playing") robotVelocity = thrust;
});

canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  if (gameState === "start") gameState = "playing";
  else if (gameState === "gameover") resetGame();
  else if (gameState === "playing") robotVelocity = thrust;
}, { passive: false });

// ===== GAME LOOP =====
function gameLoop() {
  if (!gamePaused) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBubbles();

    if (gameState === "playing") {
      updateRobot();
      if (frameCount % Math.floor(120 / gameSpeedMultiplier) === 0) createObstacle();
      drawObstacles();
      checkCollision();
      obstacleSpeed = 2 + Math.floor(score / 5) * 0.5;
    }

    drawRobot();
    if (explosions.length > 0) drawExplosions();
    drawUI();

    frameCount++;
  }
  requestAnimationFrame(gameLoop);
}

gameLoop();

// ===== SERVICE WORKER =====
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/sw.js")
    .then(() => console.log("Service Worker Registered"))
    .catch(err => console.log("SW failed to register", err));
}
</script>

</body>
</html>
